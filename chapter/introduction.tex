\section{Introduction}

- Question: How can we automatically extract features that can be engineered into a software product line from a set of given clone-and-own variants? Is it possible to do this without using any special constructs, like AST or FST, or any special knowledge about the language we input?

Context:
	- polyglot codebases with multiple implementation languages
	- inclusion of domain-specific languages (DSLs)
	- inclusion of textual requirements or configuration artifacts
	- organizations evolving systems via clone-and-own across these heterogeneous artifacts

Pain points:
	- high cost of maintaining multiple cloned forks over time
	- bug propagation across variants difficult to track and fix consistently
	- inconsistencies between implementations, DSL artifacts, and requirements
	- onboarding new variants or customers requires manual copy-and-adapt work

Limitations of existing approaches:
	- depend on language-specific parsers or frontends for each programming language
	- need adaptation or engineering effort for every new language or DSL
	- hard to apply to weird or proprietary DSLs without tool support
	- limited support for truly polyglot systems with mixed artifacts
	- often focus on a single language ecosystem rather than arbitrary text-based artifacts

input:
	- accepts any text-based artifact as input
	- operates on multiple cloned codebases as product variants
	- treats source code, DSLs, and textual requirements uniformly at token level
	- no need for language-specific parsers or grammar definitions

output:
	- one artifact per extracted feature capturing all associated code and text blocks
	- explicit separation of common blocks shared across variants
	- explicit separation of unique blocks specific to individual variants
	- a template representation of the reconstructed software product line
	- a configuration description for each variant
	- generator that uses template plus per-variant configuration to regenerate all original variants
	- possibility to define new configurations for new variants

key properties:
	- parser-free, token-based processing
	- language-agnostic by construction
	- suitable for polyglot systems and arbitrary DSLs
	- multi-level similarity (file, line, token) as core mechanism
	- focuses on automation with minimal manual intervention

Evaluation plan:
	- feasibility study rather than full empirical evaluation
	- demonstration on a deliberately intricate synthetic SPL
	- demonstration on a real-world benchmark SPL (e.g. ArgoUML)
	- qualitative assessment of correctness and practicality

Software is an ever increasing part of our society and business. Every day thousands of new lines of software are written. With more and more softare beeing needed a lot of software development companies employ techniques like clone-and-own. These allow for the quick creation of ever more new variants of the same software system. With the existens of more variants it becomes increasingly hard to maintain these different variants, e.g. if a bug is found in one in these variants, it is hard to track down if the code having this bug is present in other variants of the same system. Thats were software product line reengineering comes into play. It allows us to extract, so called feature mining, code blocks from exisiting variants and thus reduce time needed for things like maintaining the system. It also greatly reduces the time needed for creating new variants for new or existing customers or updating existing variants with new features.
There have been a lot of developments in the area of feature mining, feature extraction or also called variability mining. A lot of approaches have been presented.
