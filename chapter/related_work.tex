%NOTE: Eisi marked the earlier related-work sketch as "sehr gut", so I keep the structure
%TODO: should double-check that each cited reference really matches the described technique
%
\section{Related Work}
Research on extractive software product lines (SPLs) and variant management spans parser- and model-based reengineering, variability mining, clone-based analyses, and software transplantation. We group the most relevant strands and position our contribution accordingly.

% NOTE: Verify that the summary of ExtractorPL and FeatureHouse matches the original papers.
\paragraph{Parser- and FST-based SPL reengineering}
ExtractorPL abstracts variants into feature structure trees (FSTs) and synthesizes an SPL implementation capable of regenerating the originals~\cite{ziadi2014extractorpl}. Although the core representation is language-independent, the approach depends on programming-language specific parsers and pretty printers to translate between code and FSTs. FeatureHouse generalizes FST-based, superimposition-style composition across multiple implementation languages~\cite{apel2013featurehouse}; each supported language again requires a dedicated frontend. Our work shares the goal of programming-language independent reasoning but deliberately avoids parsers, abstract syntax trees (ASTs), and pretty printers by operating on tokenized text only.

% TODO: Decide whether I want to add a concrete citation for annotation-based extraction
% (e.g., a CIDE paper) For now keep the reference to variability-aware parsing and partial preprocessing
\paragraph{Preprocessor- and annotation-based extraction}
Annotation-centric approaches and variability-aware frontends assume explicit feature annotations or disciplined conditional compilation. Variability-aware parsing (TypeChef) builds a unified variational AST for all \texttt{\#ifdef} configurations~\cite{kastner2011variabilityaware}, while partial preprocessing produces conditional token streams suitable for subsequent analyses~\cite{kastner2011partial}. These techniques provide strong guarantees for annotated code bases but tie the pipeline to specific languages and preprocessing ecosystems. In contrast, we neither rely on annotations nor conditional compilation and remain parser-free.

% NOTE: Make sure the variability-mining references actually cover the described aspects:
% semiautomatic feature detection, industrial mining with outliers/clusters, and extractive SPL modeling
\paragraph{Variability mining and feature location}
Variability mining combines structural and textual signals to detect features and their implementations. K{\"a}stner et al.\ present a semiautomatic process that integrates multiple sources of evidence to consistently detect product-line features~\cite{kaestner2014variabilitymining}. Outlier- and cluster-based analysis has been shown to improve mining quality in industrial settings~\cite{wille2018variabilitymining}. Linsbauer et al.\ address variability extraction and modeling for product variants, with a focus on building explicit variability models and reusable artefacts from existing portfolios~\cite{linsbauer2017variability}. Bottom-up frameworks such as BUT4Reuse provide an extensible process and intermediate representations into which concrete mining and model-synthesis techniques can be plugged~\cite{martinez2015but4reuse}. Model-based delta module generation leverages mined relations to construct deltas and regenerate variants~\cite{wille2017delta}. Our method operates at a lower abstraction level: we compute programming-language independent, token-based block correspondences across artefacts that can serve as a similarity backbone within such frameworks.

% NOTE: If space allows, I could add one sentence here that explicitly contrasts the goal
% (generative representation and regeneration) with clone reporting
\paragraph{Clone-based and text-based analyses}
Token- and text-based clone detectors have been studied in SPL settings to understand and refactor feature implementations. Schulze et al.\ analyse code clones in feature-oriented SPLs to investigate their impact on maintenance and evolution~\cite{schulze2010codeclones}. We adopt a related low-level perspective (tokenization and alignment) but target an explicit, generative SPL representation that supports regeneration of variants, rather than clone reporting alone.

% TODO: Ensure that the FCA reference is indeed framed in an SPL or variability context
\paragraph{Formal concept analysis and data mining}
Formal Concept Analysis (FCA) has been proposed as a structural framework for representing commonality and variability by building lattices over artefact presence and configuration relations, which can inform feature grouping and model synthesis~\cite{galasso2025fca}. Our current pipeline stops at block presence across variants; FCA-style structuring is a complementary step on top of our extracted relations and is left as future work.

\paragraph{Software transplantation and slice-based reengineering}
Software transplantation transfers feature ``organs'' between systems via slicing and search~\cite{barr2015autotransplant}. Building on this idea, recent work explores SPL engineering via transplantation, extracting feature slices and integrating them into a base product line~\cite{souza2025foundry}. These methods typically rely on language-specific analyses and focus on moving features across systems. We instead mine a coherent representation from a set of closely related clone-and-own variants and regenerate those variants from the mined representation.

% TODO: Keep this positioning paragraph tightly coupled to the contributions list in the introduction.
\paragraph{Positioning}
Taken together, prior work demonstrates effective SPL extraction via parser-dependent analyses (ExtractorPL, FeatureHouse, TypeChef), framework-based variability mining (BUT4Reuse, FCA, variability extraction), clone analysis, and transplantation. Our contribution is a deliberately lightweight alternative: a parser-free, token-based pipeline that treats heterogeneous textual artefacts uniformly and yields a generative representation capable of regenerating the original variants, which makes it suited to polyglot, DSL-rich portfolios where programming-language specific frontends are impractical or unavailable.
